# Introduction
To download this presentation:
curl <link here> > vim-presentation

Source: Practical Vim: Edit Text at the Speed of Thought - Drew Neil

To run some commands easily:
map <Leader>x :exec getline(".")<cr>

Example:
echo "Hello World"


# Registers
:reg
list of registers

storing:
"{register}{operation}
lower case: new register
upper case: append register

accessing:
"{register}p in normal mode
<C-r>{register} in insert mode
@{register} in Ex Mode to pass a register as reference (not value)
\=@{register} in substitute command

special registers:
" unnamed register
0 yank register
1-9 history of changes and deletions
_d blackhole
+ clipboard (cut, copy, paste - OS specific)
* primary (middle mouse button - OS specific)
= expression register (usefull only in insert mode with <C-r>=
% name of the current file
# name of alternate file
. last inserted text
: last ex command
/ last search pattern


# Visual Mode
Usually not necessary

Exceptions:
- Doing something in a few lines
let a = 1
let b = 10
let c = 100000

- Copy and replace
lead_id = 1
application_id = 2

PreQualification.new(application_id)

warning: it causes side effect

Other options:
blackhole register: "_diw<Shift>p
yank register: ciw<C-r>0<Esc>

- Restricting a command

let a = 1
let b = 10
let c = 100000


# Dot Command
It is like mini macros

Ex:
let a = 1
let b = 10
let c = 100000


# Find/Replace
- c tag to confirm, last search (or / register), dot command
att
pattern
att

- e tag and gn command
att
atts

\v at the beginning when working with regex
\zs start of the match


\ze end of the match
\s match space or tab
\_s match space, tab or new line


# Ex Commands
- all normal commands: yank, delete, move, print, etc (we can use it with registers)

- Example using normal mode to append something at the end of a line

:63,65norm A;
let a = 1
let b = 10
let c = 100000


# Global Commands
Ex commands with pattern

Examples:
- append missing ";" add the end of the lets:

let a = 1
let b = 10;
let c = 100000

:73,75g/let .*[^;]$/norm A;

perform something between two patterns
:g/^startlist/+1,/^endlist/-1 sort

startlist
'grape'
'coconut'
'banana'
'strawberry'
'lemon'
endlist

startlist
'France'
'Brazil'
'Japan'
'Senegal'
'Australia'
endlist

Using register append to copy a series of lines
defining a range relative to pattern

reset register a: qaq
/\vdocument_upload_url\(\zs'\w*'\ze\)

attribute :appraisal_upload_url do
  document_upload_url('appraisal')
end

attribute :other_vehicle_documents_upload_url do
  document_upload_url('other_vehicle_documents')
end

attribute :vehicle_inqueries_upload_url do
  document_upload_url('vehicle_inqueries')
end

global!, globalv or only v: do with the lines that
does not match the pattern


# Macros
recording a macro: q<register><commands>q
executing a macro: @<register>
executing last macro: @@

Example:
Introducing a new module level in Ruby
Series of numbers


# argdo, cfdo, cdo, bufdo etc


















# Others
<C-a> increase a number
  <C-x> decrease a number
application1 = FactoryGirl.create(:application)

  xp transpose character
  Matehus



